// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "HandleData.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "../../data/Entity.h"
#include "../../data/UserActivity.h"
#include "../../data/json/elements.h"
#include "../../data/json/reader.h"
#include "../../data/json/writer.h"
#include "../../data/MemoryData.h"
#include <boost/lexical_cast.hpp>
#include <string>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace std;
using boost::shared_ptr;
using namespace json;
using namespace boost;
using namespace ::recsys;

class HandleDataHandler: virtual public HandleDataIf {
protected:
	MemoryData m_memory_data;
protected:
	void _add_entity_helper(Object const& entityObj) {
		String entityId = entityObj["id"];
		String entityType = entityObj["type"];
		Array const& featArr = entityObj["feature"];
		Entity entity(entityId.Value(),
				lexical_cast<size_t>(entityType.Value()));
		for (Array::const_iterator iter1 = featArr.Begin();
				iter1 != featArr.End(); ++iter1) {
			Object const& featObj = *iter1;
			String featName = featObj["name"];
			String featType = featObj["type"];
			String featVal = featObj["value"];
			entity.attachFeature(featName.Value(),
					lexical_cast<size_t>(featType.Value()), featVal.Value());
		}
		entity.write();
		cout << "added entity:" << entity << endl;
	}

	void _add_entity(string entityJson) {
		stringstream ss;
		ss << entityJson;
		Object entityObj;
		Reader::Read(entityObj, ss);
		_add_entity_helper(entityObj);
	}
public:
	HandleDataHandler() {
		// Your initialization goes here
		m_memory_data.load_item_profile(
				"/home/qzhao2/data/amazon-yms/ratings/item_profile");
		m_memory_data.load_rating(
				"/home/qzhao2/data/amazon-yms/ratings/processed/book_rating_san.tsv");
	}

	void import_entities(std::string& _return, const std::string& entityJson) {
		// Your implementation goes here
		printf("import_entities\n");
		/// decode the json text
		stringstream ss;
		ss << entityJson;
		Array entityArr;
		Reader::Read(entityArr, ss);
		for (Array::const_iterator iter = entityArr.Begin();
				iter != entityArr.End(); ++iter) {
			Object const& entityObj = *iter;
			_add_entity_helper(entityObj);
		}
	}

	void add_entity(std::string& _return, const std::string& entityJson) {
		// Your implementation goes here
		_add_entity(entityJson);
	}

	void add_activity(std::string& _return, const std::string& activityJson) {
		// Your implementation goes here
		stringstream ss;
		ss << activityJson;
		Object obj;
		Reader::Read(obj, ss);
		/// decode user id, activity type and context
		String userId = obj["uid"];
		String type = obj["type"];
		String context = obj["context"];
		UserActivity activity(userId.Value(),
				lexical_cast<size_t>(type.Value()), context.Value());
		cout << activity << endl;
		activity.write();
	}

	void get_recommend_list(std::string& _return, const std::string& userId) {
		// Your implementation goes here
		/// simply return top 100 recommends
		static bool isGenerated = false;
		static string recListJson;
		if (!isGenerated) {
			Array recArr;
			vector<string> const& recItems = m_memory_data.top_popular_items(
					50);
			for (size_t i = 0; i < recItems.size(); i++) {
				stringstream ss;
				string itemJson = recItems[i];
				ss << itemJson;
				Object itemObj;
				Reader::Read(itemObj, ss);
				recArr.Insert(itemObj);
			}
			stringstream ss;
			Writer::Write(recArr, ss);
			recListJson = ss.str();
			isGenerated = true;
		}
		_return = recListJson;
	}

};

int main(int argc, char **argv) {
	int port = 9090;
	shared_ptr<HandleDataHandler> handler(new HandleDataHandler());
	shared_ptr<TProcessor> processor(new HandleDataProcessor(handler));
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	shared_ptr<TTransportFactory> transportFactory(
			new TBufferedTransportFactory());
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	cout << "starting to take request" << endl;
	TSimpleServer server(processor, serverTransport, transportFactory,
			protocolFactory);
	server.serve();
	return 0;
}

