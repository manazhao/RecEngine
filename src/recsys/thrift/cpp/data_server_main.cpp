// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "HandleData.h"
#include "recsys/data/DatasetExt.h"
#include <boost/shared_ptr.hpp>
#include <boost/timer.hpp>
#include <boost/program_options.hpp>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "recsys/data/AppConfig.h"
#include "recsys/data/Entity.h"
#include "recsys/data/EntityInteraction.h"
#include "recsys/data/DataLoaderSwitcher.h"
#include "boost/filesystem.hpp"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;
using namespace ::recsys::thrift;
using namespace recsys;
using namespace boost;
namespace po = boost::program_options;
namespace bf = boost::filesystem ;

class HandleDataHandler: virtual public HandleDataIf {
protected:
	string m_dataset_name;
	DataLoader& m_data_loader;
	static map<string, int> m_dataset_port_map;
	static map<string,Entity::ENTITY_TYPE> m_entity_type_map;
public:
	static void register_dataset_port(){
		int currentPort = 9090;
		m_dataset_port_map["amazon"] = currentPort;
		m_dataset_port_map["movielens"] = ++currentPort;
	}
	static int get_dataset_port(string const& datasetName){
		return m_dataset_port_map[datasetName];
	}

	static void register_entity_type(){
		m_entity_type_map["user"] = Entity::ENT_USER;
		m_entity_type_map["item"] = Entity::ENT_ITEM;
		m_entity_type_map["feature"] = Entity::ENT_FEATURE;
	}

	HandleDataHandler(DataLoader& dataLoader):m_data_loader(dataLoader){}

	void add_entity(std::string& _return, const std::string& entityJson) {
		/// extract entity id and type from the json data
		stringstream ss;
		ss << entityJson;
		js::Object entityObj;
		/// construct json object from line
		js::Reader::Read(entityObj, ss);
		js::Object returnObj;
		returnObj["status"] = js::String("success");
		returnObj["message"] = js::String("");
		bool status = true;
		/// find the id and type
		if (entityObj.Find("id") != entityObj.End() && entityObj.Find("type") != entityObj.End()) {
			js::String id = entityObj["id"];
			js::String type = entityObj["type"];
			if(id.Value().empty()){
				returnObj["status"] = "fail";
				returnObj["message"] = "empty entity id";
				status = false;
			}
			if(m_entity_type_map.find(type.Value()) == m_entity_type_map.end()){
				returnObj["status"] = "fail";
				returnObj["message"] = "unsupported entity type";
				status = false;
			}
			if(status){
				Entity::ENTITY_TYPE entType = m_entity_type_map[type.Value()];
				Entity entity(id.Value(),entType);
				Entity::entity_ptr entityPtr = entity.index_if_not_exist();
				/// get the mapped id
				returnObj["id"] = entityPtr->get_mapped_id();
			}
		}else{
			returnObj["status"] = js::String("fail");
			returnObj["message"] = "entity id or type is missing";
		}
		stringstream returnSS;
		js::Writer(returnObj, returnSS);
		_return = returnSS.str();
	}

	void add_interaction(std::string& _return,
			const std::string& interactionJson) {
		// Your implementation goes here
		printf("add_interaction\n");
	}

	void get_recommend_list(std::string& _return, const std::string& userId) {
		// Your implementation goes here
		printf("get_recommend_list\n");
	}

	void get_dataset(Dataset& _return, const DSType::type dsType) {
		// Your implementation goes here
		printf("get_dataset\n");
		_return = m_data_loader.dataset(dsType);
	}

};

//// static members
map<string, int> HandleDataHandler::m_dataset_port_map;
map<string,Entity::ENTITY_TYPE> HandleDataHandler::m_entity_type_map;


/// parse commandline arguments
void parse_app_args(int argc, char** argv, string& datasetName, string& userFile, string& itemFile, string& ratingFile) {
	po::options_description desc(
			"Load dataset into main memory and share with other applications through thrift interface");
	desc.add_options()
			("help", "help message on use this application")
					("user-file,u", po::value<string>(&userFile),"user profile file")
					("item-file,i", po::value<string>(&itemFile), "item profile file")
					("rating-file,r", po::value<string>(&ratingFile)->required(),"rating file")
					("dataset-name,n", po::value<string>(&datasetName)->required(),"dataset name: should be one of [amazon,movielens]");

	try {
		po::variables_map vm;
		po::store(po::parse_command_line(argc, argv, desc), vm);
		if (vm.count("help")) {
			cout << desc << "\n";
			exit(1);
		}
		/// check all required options are provided
		vm.notify();
	} catch (std::exception& e) {
		cerr << "Error:" << e.what() << "\n\n";
		cout << "Usage:" << "\n";
		cout << desc << "\n";
		exit(1);
	}
}

int main(int argc, char **argv) {
	string datasetName;
	string userFile, itemFile, ratingFile;
	/// parse commandline arguments
	parse_app_args(argc, argv,datasetName, userFile, itemFile, ratingFile);

	/// register listening port
	HandleDataHandler::register_dataset_port();
	HandleDataHandler::register_entity_type();

	/// get the data loader
	DataLoaderSwitcher& dlSwitcher = DataLoaderSwitcher::ref();
	shared_ptr<DataLoader> dataLoaderPtr = dlSwitcher.get_local_loader(datasetName, userFile, itemFile, ratingFile);

	/// attach data loader to the handler
	shared_ptr<HandleDataHandler> handler(
			new HandleDataHandler(*dataLoaderPtr));

	/// run Thrift Service
	/// get the port number assigned to the given dataset
	int port = HandleDataHandler::get_dataset_port(datasetName);
	shared_ptr<TProcessor> processor(new HandleDataProcessor(handler));
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	shared_ptr<TTransportFactory> transportFactory(
			new TBufferedTransportFactory());
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
	TSimpleServer server(processor, serverTransport, transportFactory,
			protocolFactory);
	cout << "dataset is loaded, start the sharing service at: " << port << endl;
	server.serve();
	return 0;
}

