// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "HandleData.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "recsys/data/AppConfig.h"
#include "recsys/data/Entity.h"
#include "recsys/data/EntityInteraction.h"
#include "recsys/data/AmazonJSONDataLoader.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::recsys::thrift;
using namespace recsys;

class HandleDataHandler : virtual public HandleDataIf {
protected:
	void _load_amazon_data(){
		string authorFile = "/home/qzhao2/data/amazon-yms/ratings/processed/author_profile.json";
		string itemFile = "/home/qzhao2/data/amazon-yms/ratings/processed/item_profile.json";
		string ratingFile = "/home/qzhao2/data/amazon-yms/ratings/processed/book_rating_filter.json";
		AmazonJSONDataLoader amazonDataLoader;
		amazonDataLoader.load_author_profile(authorFile);
		amazonDataLoader.load_item_profile(itemFile);
		amazonDataLoader.load_rating_file(ratingFile);
	}
 public:
  HandleDataHandler() {
    // Your initialization goes here
	  cout << "loading Amazon book rating data..." << endl;
	 _load_amazon_data();
	 cout << "loading finished, ready to take request..." << endl;
  }

  void import_entities(std::string& _return, const std::string& entityJson) {
    // Your implementation goes here
    printf("import_entities\n");
  }

  void add_entity(std::string& _return, const std::string& entityJson) {
    // Your implementation goes here
    printf("add_entity\n");
  }

  void add_activity(std::string& _return, const std::string& activityJson) {
    // Your implementation goes here
    printf("add_activity\n");
  }

  void get_recommend_list(std::string& _return, const std::string& userId) {
    // Your implementation goes here
    printf("get_recommend_list\n");
  }

  int64_t get_max_id(const int8_t entType) {
    // Your implementation goes here
    printf("get_max_id\n");
    return Entity::m_type_max_id_map[entType];
  }

  void get_interacts(std::map<int8_t, std::vector<Interact> > & _return, const int64_t entId, const int8_t entType) {
    // Your implementation goes here
    printf("get_interacts\n");
    EntityInteraction::type_entity_interact_map& interactMap = EntityInteraction::m_type_entity_interact_map;
    EntityInteraction::entity_interact_vec_ptr& entInteracts = interactMap[entType][entId];
    if(entInteracts){
    	for(EntityInteraction::entity_interact_vec::const_iterator iter = entInteracts->begin(); iter != entInteracts->end(); ++iter){
    		EntityInteraction const& tmpInteract = **iter;
    		Interact tmpInteract2;
    		tmpInteract2.ent_type = tmpInteract.m_to_entity->m_type;
    		tmpInteract2.ent_id = tmpInteract.m_to_entity->m_mapped_id;
    		if(tmpInteract.m_val.Find("v") != tmpInteract.m_val.End()){
    			js::String val = tmpInteract.m_val["v"];
    			tmpInteract2.int_val = val.Value();
    		}
    		_return[tmpInteract.m_type].push_back(tmpInteract2);
    	}
    }
  }
};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<HandleDataHandler> handler(new HandleDataHandler());
  shared_ptr<TProcessor> processor(new HandleDataProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

