// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "HandleData.h"
#include "recsys/data/DatasetExt.h"
#include <boost/shared_ptr.hpp>
#include <boost/timer.hpp>
#include <boost/program_options.hpp>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "recsys/data/AppConfig.h"
#include "recsys/data/Entity.h"
#include "recsys/data/EntityInteraction.h"
#include "recsys/data/DataLoaderSwitcher.h"
#include "boost/filesystem.hpp"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;
using namespace ::recsys::thrift;
using namespace recsys;
using namespace boost;
namespace po = boost::program_options;
namespace bf = boost::filesystem ;

class HandleDataHandler: virtual public HandleDataIf {
protected:
	/// dataset unique id
	/// currently support:
	/// amazon: amazond dataset
	string m_dataset_name;
	DataLoader& m_data_loader;
	static map<string, int> m_dataset_port_map;
public:
	static void register_dataset_port(){
		int currentPort = 9090;
		m_dataset_port_map["amazon"] = currentPort;
		m_dataset_port_map["movielens"] = ++currentPort;
	}

	static int get_dataset_port(string const& datasetName){
		return m_dataset_port_map[datasetName];
	}

	HandleDataHandler(DataLoader& dataLoader):m_data_loader(dataLoader){}

	void add_entity(std::string& _return, const std::string& entityJson) {
		// Your implementation goes here
		printf("add_entity\n");
	}

	void add_interaction(std::string& _return,
			const std::string& interactionJson) {
		// Your implementation goes here
		printf("add_interaction\n");
	}

	void get_recommend_list(std::string& _return, const std::string& userId) {
		// Your implementation goes here
		printf("get_recommend_list\n");
	}

	void get_dataset(Dataset& _return, const DSType::type dsType) {
		// Your implementation goes here
		printf("get_dataset\n");
		_return = m_data_loader.dataset(dsType);
	}

};

map<string, int> HandleDataHandler::m_dataset_port_map;

/// parse commandline arguments
void parse_app_args(int argc, char** argv, string& datasetName, string& userFile, string& itemFile, string& ratingFile) {
	po::options_description desc(
			"Load dataset into main memory and share with other applications through thrift interface");
	desc.add_options()
			("help", "help message on use this application")
					("user-file,u", po::value<string>(&userFile),"user profile file")
					("item-file,i", po::value<string>(&itemFile), "item profile file")
					("rating-file,r", po::value<string>(&ratingFile)->required(),"rating file")
					("dataset-name,n", po::value<string>(&datasetName)->required(),"dataset name: should be one of [amazon,movielens]");

	try {
		po::variables_map vm;
		po::store(po::parse_command_line(argc, argv, desc), vm);
		if (vm.count("help")) {
			cout << desc << "\n";
			exit(1);
		}
		/// check all required options are provided
		vm.notify();
	} catch (std::exception& e) {
		cerr << "Error:" << e.what() << "\n\n";
		cout << "Usage:" << "\n";
		cout << desc << "\n";
		exit(1);
	}
}

int main(int argc, char **argv) {
	string datasetName;
	string userFile, itemFile, ratingFile;
	/// parse commandline arguments
	parse_app_args(argc, argv,datasetName, userFile, itemFile, ratingFile);
	/// register listening port
	HandleDataHandler::register_dataset_port();
	/// get the data loader
	DataLoaderSwitcher& dlSwitcher = DataLoaderSwitcher::ref();
	DataLoader& dataLoader = dlSwitcher.get_local_loader(datasetName, userFile, itemFile, ratingFile);

	/// attach data loader to the handler
	shared_ptr<HandleDataHandler> handler(
			new HandleDataHandler(dataLoader));

	/// run Thrift Service
	/// get the port number assigned to the given dataset
	int port = HandleDataHandler::get_dataset_port(datasetName);
	shared_ptr<TProcessor> processor(new HandleDataProcessor(handler));
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	shared_ptr<TTransportFactory> transportFactory(
			new TBufferedTransportFactory());
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
	TSimpleServer server(processor, serverTransport, transportFactory,
			protocolFactory);
	cout << "dataset is loaded, start the sharing service at: " << port << endl;
	server.serve();
	return 0;
}

